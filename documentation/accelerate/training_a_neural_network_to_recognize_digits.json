{
  "abstract": [
    {
      "type": "text",
      "text": "Build a simple neural network and train it to recognize randomly generated numbers."
    }
  ],
  "documentVersion": 0,
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.documentation/documentation/accelerate"
      ]
    ]
  },
  "identifier": {
    "url": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits",
    "interfaceLanguage": "occ"
  },
  "legacy_identifier": 3640003,
  "kind": "article",
  "metadata": {
    "title": "Training a Neural Network to Recognize Digits",
    "role": "sampleCode",
    "roleHeading": "Sample Code",
    "modules": [
      {
        "name": "Accelerate"
      }
    ],
    "platforms": [
      {
        "name": "macOS",
        "introducedAt": "12.0",
        "current": "12.1"
      },
      {
        "name": "Xcode",
        "introducedAt": "13.0",
        "current": "13.2"
      }
    ]
  },
  "schemaVersion": {
    "major": 0,
    "minor": 1,
    "patch": 0
  },
  "sections": [],
  "variants": [
    {
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ],
      "paths": [
        "documentation/accelerate/training_a_neural_network_to_recognize_digits"
      ]
    },
    {
      "traits": [
        {
          "interfaceLanguage": "swift"
        }
      ],
      "paths": [
        "documentation/accelerate/training_a_neural_network_to_recognize_digits"
      ]
    }
  ],
  "references": {
    "doc://com.apple.documentation/documentation/accelerate": {
      "title": "Accelerate",
      "identifier": "doc://com.apple.documentation/documentation/accelerate",
      "url": "/documentation/accelerate",
      "type": "topic",
      "kind": "symbol",
      "role": "collection"
    },
    "doc://com.apple.documentation/documentation/accelerate/bnnsfilterparameters": {
      "title": "BNNSFilterParameters",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/bnnsfilterparameters",
      "kind": "symbol",
      "role": "symbol",
      "url": "/documentation/accelerate/bnnsfilterparameters"
    },
    "doc://com.apple.documentation/documentation/accelerate/bnnsflags/2915304-useclientpointer": {
      "title": "useClientPointer",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/bnnsflags/2915304-useclientpointer",
      "kind": "symbol",
      "role": "symbol",
      "url": "/documentation/accelerate/bnnsflags/2915304-useclientpointer"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861656": {
      "title": "Listing 2",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861656",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861656"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861658": {
      "title": "Listing 3",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861658",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861658"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861659": {
      "title": "Listing 4",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861659",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861659"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861660": {
      "title": "Listing 5",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861660",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861660"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861662": {
      "title": "Listing 6",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861662",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861662"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861664": {
      "title": "Listing 7",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861664",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861664"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861665": {
      "title": "Listing 8",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861665",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861665"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861667": {
      "title": "Listing 9",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861667",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861667"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861669": {
      "title": "Listing 10",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861669",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861669"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861670": {
      "title": "Listing 11",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861670",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861670"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861672": {
      "title": "Listing 12",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861672",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861672"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861674": {
      "title": "Listing 13",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861674",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861674"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861676": {
      "title": "Listing 14",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861676",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861676"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861678": {
      "title": "Listing 15",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861678",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861678"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861680": {
      "title": "Listing 16",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861680",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861680"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861682": {
      "title": "Listing 17",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861682",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861682"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861683": {
      "title": "Listing 18",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861683",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861683"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861684": {
      "title": "Listing 19",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861684",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861684"
    },
    "link-media-3861686": {
      "identifier": "link-media-3861686",
      "type": "link",
      "title": "Figure 2",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861686"
    },
    "media-3861686": {
      "identifier": "media-3861686",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x"
          ],
          "size": {
            "width": 698,
            "height": 289
          },
          "url": "https://docs-assets.developer.apple.com/published/dbd7afe055/rendered2x-1595837701.png"
        }
      ],
      "alt": "A graph with loss as the y-axis and training epochs as the x-axis that shows loss decreasing during training.",
      "title": "Figure 2"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861687": {
      "title": "Listing 20",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861687",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861687"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861688": {
      "title": "Listing 21",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861688",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861688"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861689": {
      "title": "Listing 22",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861689",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861689"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861690": {
      "title": "Listing 23",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861690",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861690"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861691": {
      "title": "Listing 24",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861691",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861691"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861654": {
      "title": "Listing 1",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861654",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861654"
    },
    "link-media-3861653": {
      "identifier": "link-media-3861653",
      "type": "link",
      "title": "Figure 1",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits#3861653"
    },
    "media-3861653": {
      "identifier": "media-3861653",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x"
          ],
          "size": {
            "width": 709,
            "height": 395
          },
          "url": "https://docs-assets.developer.apple.com/published/b3a114a480/rendered2x-1597657781.png"
        }
      ],
      "alt": "A flow diagram that shows the flow of information during the training phase of the sample code project.",
      "title": "Figure 1"
    },
    "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits": {
      "title": "Training a Neural Network to Recognize Digits",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/training_a_neural_network_to_recognize_digits",
      "kind": "article",
      "role": "sampleCode",
      "url": "/documentation/accelerate/training_a_neural_network_to_recognize_digits",
      "abstract": [
        {
          "type": "text",
          "text": "Build a simple neural network and train it to recognize randomly generated numbers."
        }
      ]
    },
    "doc://com.apple.documentation/documentation/accelerate/bnns": {
      "title": "BNNS",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/accelerate/bnns",
      "kind": "article",
      "role": "collectionGroup",
      "url": "/documentation/accelerate/bnns",
      "abstract": [
        {
          "type": "text",
          "text": "Implement and run neural networks for training and inference."
        }
      ]
    },
    "https://docs-assets.developer.apple.com/published/89e583069c/TrainingANeuralNetworkToRecognizeDigits.zip": {
      "type": "download",
      "identifier": "https://docs-assets.developer.apple.com/published/89e583069c/TrainingANeuralNetworkToRecognizeDigits.zip",
      "checksum": "fa5d336e410ac46faf02f73d6e135c01f80fd2673a7c66be93ae6864e11c0550e8432bb44401ecc40f8dcc210847afa14a5c8875af638ee8a87ba45a81f0857c",
      "url": "https://docs-assets.developer.apple.com/published/89e583069c/TrainingANeuralNetworkToRecognizeDigits.zip"
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "url": "/documentation/technologies",
      "kind": "technologies",
      "title": "Technologies"
    }
  },
  "sampleCodeDownload": {
    "action": {
      "overridingTitle": "Download",
      "type": "reference",
      "isActive": true,
      "identifier": "https://docs-assets.developer.apple.com/published/89e583069c/TrainingANeuralNetworkToRecognizeDigits.zip"
    }
  },
  "seeAlsoSections": [
    {
      "identifiers": [
        "doc://com.apple.documentation/documentation/accelerate/bnns"
      ],
      "title": "Neural Networks",
      "generated": true
    }
  ],
  "primaryContentSections": [
    {
      "kind": "content",
      "content": [
        {
          "anchor": "overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "This sample code project shows you how to use BNNS to create a simple neural network that’s capable of recognizing digits."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample iterates over randomly generated digits in the training phase, incrementally improving its ability to recognize numbers. After the code completes the training phase, it evaluates its accuracy at recognizing numbers, and returns a score."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "A 6 x 6 matrix represents each digit. For example, the following code represents the number 3:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static let three: [Float] = [0, 1, 1, 1, 1, 0,  // ⚪️⚫️⚫️⚫️⚫️⚪️",
            "                             0, 0, 0, 0, 1, 0,  // ⚪️⚪️⚪️⚪️⚫️⚪️",
            "                             0, 1, 1, 1, 1, 0,  // ⚪️⚫️⚫️⚫️⚫️⚪️",
            "                             0, 0, 0, 0, 1, 0,  // ⚪️⚪️⚪️⚪️⚫️⚪️",
            "                             0, 1, 1, 1, 1, 0,  // ⚪️⚫️⚫️⚫️⚫️⚪️",
            "                             0, 0, 0, 0, 0, 0]  // ⚪️⚪️⚪️⚪️⚪️⚪️"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861654",
            "title": "Listing 1"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The network consists of three layers:"
            }
          ]
        },
        {
          "type": "unorderedList",
          "items": [
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Fused convolution-batch normalization layer"
                    }
                  ]
                }
              ]
            },
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Pooling layer"
                    }
                  ]
                }
              ]
            },
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Fully connected layer"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "After the code completes a forward pass, it calculates its loss, which is a score that indicates how the predicted values deviate from the labels. The sample code project uses the gradients that the loss generates as the basis for the backward pass, where it backward-applies the three layers in reverse order."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The backward passes generate gradient values that an optimizer uses to update the following parameters:"
            }
          ]
        },
        {
          "type": "unorderedList",
          "items": [
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Convolution weights, that initialize with random values, and bias"
                    }
                  ]
                }
              ]
            },
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Normalization beta (offset) and gamma (scale)"
                    }
                  ]
                }
              ]
            },
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Fully connected weights"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The optimizer’s gradual changes to the weights, bias, beta, and gamma increases the network’s efficacy in recognizing digits with each iteration."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following image shows the relationships between the layers:"
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "image",
              "identifier": "media-3861653",
              "metadata": {
                "anchor": "3861653",
                "title": "Figure 1"
              }
            }
          ]
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Define the Filter Parameters",
          "anchor": "3861694"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample creates a "
            },
            {
              "type": "reference",
              "isActive": true,
              "identifier": "doc://com.apple.documentation/documentation/accelerate/bnnsfilterparameters"
            },
            {
              "type": "text",
              "text": " structure with "
            },
            {
              "type": "reference",
              "isActive": true,
              "identifier": "doc://com.apple.documentation/documentation/accelerate/bnnsflags/2915304-useclientpointer"
            },
            {
              "type": "text",
              "text": ". This flag instructs the layers to keep the provided pointers at creation time, and to work directly from that data rather than use internal copies of the data."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static var filterParameters = BNNSFilterParameters(",
            "    flags: BNNSFlags.useClientPointer.rawValue,",
            "    n_threads: 1,",
            "    alloc_memory: nil,",
            "    free_memory: nil)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861656",
            "title": "Listing 2"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Fused Convolution-Batch Normalization Layer",
          "anchor": "3861695"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The convolution-batch normalization layer consists of two sublayers:"
            }
          ]
        },
        {
          "type": "unorderedList",
          "items": [
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Convolution layers that generate their output by multiplying each input value and its neighbors by corresponding values in an array of weights, and then adding a corresponding bias. Each output value is the sum of each of those operations. Convolution layers are fundamental to convolutional neural networks and, with the correct weights and bias values, can identify features, such as horizontal and vertical lines."
                    }
                  ]
                }
              ]
            },
            {
              "content": [
                {
                  "type": "paragraph",
                  "inlineContent": [
                    {
                      "type": "text",
                      "text": "Normalization layers that rescale their data so that all of the batches of data have the same standard deviation."
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The convolution weights array initializes with random values."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static let convolutionWeights: BNNSNDArrayDescriptor = {",
            "    let convolutionKernelSize = 3",
            "    ",
            "    let convolutionWeightsShape = BNNS.Shape.convolutionWeightsOIHW(",
            "        convolutionKernelSize,",
            "        convolutionKernelSize,",
            "        convolutionInputImageChannels,",
            "        convolutionOutputImageChannels)",
            "    ",
            "    guard let desc = BNNSNDArrayDescriptor.allocate(",
            "        randomUniformUsing: randomGenerator,",
            "        range: Float(-0.5)...Float(0.5),",
            "        shape: convolutionWeightsShape) else {",
            "        fatalError(\"Unable to create `convolutionWeightsArray`.\")",
            "    }",
            "    return desc",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861658",
            "title": "Listing 3"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The convolution bias, and the batch normalization beta and gamma arrays initialize by repeating a scalar value."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static let convolutionBias = BNNSNDArrayDescriptor.allocate(",
            "    repeating: Float(0),",
            "    shape: .vector(convolutionOutputImageChannels))",
            "",
            "static let featureMaps = convolutionOutputImageChannels",
            "",
            "static let batchNormBeta = BNNSNDArrayDescriptor.allocate(",
            "    repeating: Float(0),",
            "    shape: .vector(featureMaps),",
            "    batchSize: batchSize)",
            "",
            "static let batchNormGamma = BNNSNDArrayDescriptor.allocate(",
            "    repeating: Float(1),",
            "    shape: .vector(featureMaps),",
            "    batchSize: batchSize)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861659",
            "title": "Listing 4"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code creates the fused layer that applies convolution and normalization to the input:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static let fusedConvBatchNormLayer: BNNS.FusedParametersLayer = {",
            "    ",
            "    let convolutionParameters = BNNS.FusedConvolutionParameters(type: .standard,",
            "                                                                weights: convolutionWeights,",
            "                                                                bias: convolutionBias,",
            "                                                                stride: (1, 1),",
            "                                                                dilationStride: (1, 1),",
            "                                                                groupSize: 1,",
            "                                                                padding: .symmetric(x: convolutionPadding,",
            "                                                                                    y: convolutionPadding))",
            "    ",
            "    let normalizationParameters = BNNS.FusedNormalizationParameters(type: .batch(movingMean: batchNormMovingMean,",
            "                                                                                 movingVariance: batchNormMovingVariance),",
            "                                                                    beta: batchNormBeta,",
            "                                                                    gamma: batchNormGamma,",
            "                                                                    momentum: 0.9,",
            "                                                                    epsilon: 1e-07,",
            "                                                                    activation: .rectifiedLinear)",
            "    ",
            "    guard let layer = BNNS.FusedParametersLayer(input: input,",
            "                                                output: batchNormOutput,",
            "                                                fusedLayerParameters: [convolutionParameters, normalizationParameters],",
            "                                                filterParameters: filterParameters) else {",
            "        fatalError(\"unable to create fusedConvBatchnormLayer\")",
            "    }",
            "    ",
            "    return layer",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861660",
            "title": "Listing 5"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Pooling Layer",
          "anchor": "3861696"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "Pooling layers downscale their input while preserving the most important information, and produce an output that, in the case of this sample code project, consists of the maximum value in each input pixel’s local neighborhood."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code creates the pooling layer:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static var poolingLayer: BNNS.PoolingLayer = {",
            "    guard let poolingLayer = BNNS.PoolingLayer(",
            "        type: .max(xDilationStride: 1, yDilationStride: 1),",
            "        input: batchNormOutput,",
            "        output: poolingOutput,",
            "        bias: nil,",
            "        activation: .identity,",
            "        kernelSize: (2, 2),",
            "        stride: (2, 2),",
            "        padding: .zero,",
            "        filterParameters: filterParameters) else {",
            "        fatalError(\"Unable to create `poolingLayer`.\")",
            "    }",
            "    ",
            "    return poolingLayer",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861662",
            "title": "Listing 6"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Fully Connected Layer",
          "anchor": "3861697"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "Fully connected layers compute the matrix-vector product of a weights matrix and its input, flattening the data to predict the correct label."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The fully connected weights array initializes with random values."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static let fullyConnectedWeights: BNNSNDArrayDescriptor = {",
            "    guard let desc = BNNSNDArrayDescriptor.allocate(",
            "        randomUniformUsing: randomGenerator,",
            "        range: Float(-0.5)...Float(0.5),",
            "        shape: .matrixRowMajor(poolingOutputSize,",
            "                               fullyConnectedOutputWidth)) else {",
            "        fatalError(\"Unable to create `fullyConnectedWeightsArray`.\")",
            "    }",
            "    return desc",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861664",
            "title": "Listing 7"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code creates the fully connected layer:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static var fullyConnectedLayer: BNNS.FullyConnectedLayer = {",
            "    ",
            "    let desc = BNNSNDArrayDescriptor(dataType: .float,",
            "                                     shape: .vector(poolingOutputSize))",
            "    ",
            "    guard let fullyConnectedLayer = BNNS.FullyConnectedLayer(",
            "            input: desc,",
            "            output: fullyConnectedOutput,",
            "            weights: fullyConnectedWeights,",
            "            bias: nil,",
            "            activation: .identity,",
            "            filterParameters: filterParameters) else {",
            "        fatalError(\"Unable to create `fullyConnectedLayer`.\")",
            "    }",
            "    ",
            "    return fullyConnectedLayer",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861665",
            "title": "Listing 8"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Loss Layer",
          "anchor": "3861698"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The loss layer is responsible for quantifying a score that indicates how the predicted values deviate from the labels."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code creates the loss layer:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static var lossLayer: BNNS.LossLayer = {",
            "    ",
            "    guard let lossLayer = BNNS.LossLayer(input: fullyConnectedOutput,",
            "                                         output: lossOutput,",
            "                                         lossFunction: .softmaxCrossEntropy(labelSmoothing: 0),",
            "                                         lossReduction: .reductionMean,",
            "                                         filterParameters: filterParameters) else {",
            "        fatalError(\"Unable to create `lossLayer`.\")",
            "    }",
            "    ",
            "    return lossLayer",
            "}()"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861667",
            "title": "Listing 9"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Candidate Input",
          "anchor": "3861699"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "For each iteration of the training phase, the sample creates a matrix that represents a random digit, and a "
            },
            {
              "type": "emphasis",
              "inlineContent": [
                {
                  "type": "text",
                  "text": "one-hot"
                }
              ]
            },
            {
              "type": "text",
              "text": " encoded tensor of the same digit. The sample places digits randomly in a 20 x 20 matrix, so a "
            },
            {
              "type": "codeVoice",
              "code": "3"
            },
            {
              "type": "text",
              "text": " might appear in the matrix as the following, with "
            },
            {
              "type": "codeVoice",
              "code": "0"
            },
            {
              "type": "text",
              "text": " rendering as "
            },
            {
              "type": "codeVoice",
              "code": "⚪️"
            },
            {
              "type": "text",
              "text": ", and "
            },
            {
              "type": "codeVoice",
              "code": "1"
            },
            {
              "type": "text",
              "text": " rendering as "
            },
            {
              "type": "codeVoice",
              "code": "⚫️"
            },
            {
              "type": "text",
              "text": ":"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚫️⚫️⚫️⚫️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚫️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚫️⚫️⚫️⚫️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚫️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚫️⚫️⚫️⚫️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️",
            "⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️⚪️"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861669",
            "title": "Listing 10"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The "
            },
            {
              "type": "emphasis",
              "inlineContent": [
                {
                  "type": "text",
                  "text": "one-hot"
                }
              ]
            },
            {
              "type": "text",
              "text": " encoded tensor contains a "
            },
            {
              "type": "codeVoice",
              "code": "1"
            },
            {
              "type": "text",
              "text": " at the zero-based index of "
            },
            {
              "type": "codeVoice",
              "code": "3"
            },
            {
              "type": "text",
              "text": "."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861670",
            "title": "Listing 11"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample code project uses a batch size of 32, so each iteration actually generates 32 random digits in random positions in the 20 x 20 grid."
            }
          ]
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Perform the Forward Pass",
          "anchor": "3861700"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "To perform the forward pass, call "
            },
            {
              "type": "codeVoice",
              "code": "apply"
            },
            {
              "type": "text",
              "text": " on the fused, pooling, and fully connected layers."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try fusedConvBatchNormLayer.apply(batchSize: batchSize,",
            "                                  input: input,",
            "                                  output: batchNormOutput,",
            "                                  for: .training)",
            "",
            "try poolingLayer.apply(batchSize: batchSize,",
            "                       input: batchNormOutput,",
            "                       output: poolingOutput)",
            "",
            "try fullyConnectedLayer.apply(batchSize: batchSize,",
            "                              input: poolingOutput,",
            "                              output: fullyConnectedOutput)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861672",
            "title": "Listing 12"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Calculate the Loss and Loss Gradient",
          "anchor": "3861701"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "Calculating the loss evaluates the efficacy of the neural network. The loss layer generates its output, "
            },
            {
              "type": "codeVoice",
              "code": "lossOutput"
            },
            {
              "type": "text",
              "text": ", which contains a score that indicates how the predicted values deviate from the labels, and "
            },
            {
              "type": "codeVoice",
              "code": "lossInputGradient"
            },
            {
              "type": "text",
              "text": ", which is the output gradient parameter to the backward application of the fully connected layer."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code applies the loss filter:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try lossLayer.apply(batchSize: batchSize,",
            "                    input: fullyConnectedOutput,",
            "                    labels: oneHotLabels,",
            "                    output: lossOutput,",
            "                    generatingInputGradient: lossInputGradient)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861674",
            "title": "Listing 13"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Create the Optimizer",
          "anchor": "3861702"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The optimizer is responsible for updating the weights, biases, beta, and gamma. In the following example, the sample code project creates an optimizer using the Adam algorithm:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "static var adam = BNNS.AdamOptimizer(learningRate: 0.01,",
            "                                     timeStep: 1,",
            "                                     gradientScale: 1,",
            "                                     regularizationScale: 0.01,",
            "                                     gradientClipping: .byValue(bounds: -0.5 ... 0.5),",
            "                                     regularizationFunction: BNNSOptimizerRegularizationL2)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861676",
            "title": "Listing 14"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Perform a Backward Pass and Optimization Step on the Fully Connected Layer",
          "anchor": "3861703"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample code project performs the backward pass in reverse order to the forward pass. Therefore, the sample’s first step is to call "
            },
            {
              "type": "codeVoice",
              "code": "applyBackward"
            },
            {
              "type": "text",
              "text": " on the fully connected layer, and perform an optimization step on its weights."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The "
            },
            {
              "type": "codeVoice",
              "code": "applyBackward"
            },
            {
              "type": "text",
              "text": " call on the fully connected layer generates an input gradient that’s the output gradient for the pooling layer’s backward apply, and a weights gradient that passes to the fully connected optimizer step."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code performs the backward pass:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try fullyConnectedLayer.applyBackward(",
            "    batchSize: batchSize,",
            "    input: poolingOutput,",
            "    output: fullyConnectedOutput,",
            "    outputGradient: lossInputGradient,",
            "    generatingInputGradient: fullyConnectedInputGradient,",
            "    generatingWeightsGradient: fullyConnectedWeightGradient)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861678",
            "title": "Listing 15"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Perform a Backward Pass on the Pooling Layer",
          "anchor": "3861704"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The backward pass on the pooling layer generates an input gradient that’s the output gradient to the backward apply of the fused layer."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code performs the backward pass:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try poolingLayer.applyBackward(",
            "    batchSize: batchSize,",
            "    input: batchNormOutput,",
            "    output: poolingOutput,",
            "    outputGradient: fullyConnectedInputGradient,",
            "    generatingInputGradient: poolingInputGradientArray)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861680",
            "title": "Listing 16"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Perform a Backward Pass and Optimization Step on the Fused Layer",
          "anchor": "3861705"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample calls "
            },
            {
              "type": "codeVoice",
              "code": "applyBackward"
            },
            {
              "type": "text",
              "text": " on the fused layer, and performs an optimization step on its convolution’s weights and bias, as well as its normalization’s beta and gamma."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code performs the backward pass:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "let gradientParameters = [convolutionWeightGradient,",
            "                          convolutionBiasGradient,",
            "                          batchNormBetaGradient,",
            "                          batchNormGammaGradient]",
            "",
            "try fusedConvBatchNormLayer.applyBackward(",
            "    batchSize: batchSize,",
            "    input: input,",
            "    output: batchNormOutput,",
            "    outputGradient: poolingInputGradientArray,",
            "    generatingInputGradient: convolutionInputGradient,",
            "    generatingParameterGradients: gradientParameters)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861682",
            "title": "Listing 17"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code performs the optimization step:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try adam.step(",
            "    parameters: [fullyConnectedWeights,",
            "                 convolutionWeights, convolutionBias,",
            "                 batchNormBeta, batchNormGamma],",
            "    gradients: [fullyConnectedWeightGradient,",
            "                convolutionWeightGradient, convolutionBiasGradient,",
            "                batchNormBetaGradient, batchNormGammaGradient],",
            "    accumulators: [fullyConnectedWeightAccumulator1,",
            "                   convolutionWeightAccumulator1, convolutionBiasAccumulator1,",
            "                   batchNormBetaAccumulator1, batchNormGammaAccumulator1,",
            "                   fullyConnectedWeightAccumulator2,",
            "                   convolutionWeightAccumulator2, convolutionBiasAccumulator2,",
            "                   batchNormBetaAccumulator2, batchNormGammaAccumulator2],",
            "    filterParameters: filterParameters)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861683",
            "title": "Listing 18"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "After the sample completes all the optimization steps for this iteration, it increments the optimizer time step."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "adam.timeStep += 1"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861684",
            "title": "Listing 19"
          }
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Evaluate the Neural Network",
          "anchor": "3861706"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample iterates over the forward, loss, backward, and optimization steps, and with each iteration, the trend of the loss is to reduce. The following graph shows the loss, as a solid stroke, decreasing during training:"
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "image",
              "identifier": "media-3861686",
              "metadata": {
                "anchor": "3861686",
                "title": "Figure 2"
              }
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The code in the sample defines a maximum number of iterations. Additionally, it calculates a moving average of recent loss values, which appear as a dashed stroke in the graph above. At each iteration, the sample checks whether the recent average loss is below that threshold, and, if it is, it breaks from the training phase early."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "let maximumIterationCount = 1000",
            "",
            "// The `recentLosses` array contains the last `recentLossesCount` losses.",
            "let recentLossesCount = 20",
            "var recentLosses = [Float]()",
            "",
            "// The `averageRecentLossThreshold` constant defines the loss threshold",
            "// at which to consider the training phase complete.",
            "let averageRecentLossThreshold = Float(0.125)",
            "",
            "for epoch in 0 ..< maximumIterationCount {",
            "    if epoch == 500 {",
            "        adam.learningRate /= 10",
            "    }",
            "    ",
            "    generateInputAndLabels()",
            "    forwardPass()",
            "    computeLoss()",
            "    ",
            "    guard let loss = lossOutput.makeArray(of: Float.self,",
            "                                          batchSize: 1)?.first else {",
            "        print(\"Unable to calculate loss.\")",
            "        return",
            "    }",
            "    ",
            "    if recentLosses.isEmpty {",
            "        recentLosses = [Float](repeating: loss,",
            "                               count: recentLossesCount)",
            "    }",
            "    ",
            "    recentLosses[epoch % recentLossesCount] = loss",
            "    let averageRecentLoss = vDSP.mean(recentLosses)",
            "    ",
            "    if epoch % 10 == 0 {",
            "        print(\"Epoch \\(epoch): \\(loss) : \\(averageRecentLoss)\")",
            "    }",
            "    ",
            "    if averageRecentLoss < averageRecentLossThreshold {",
            "        print(\"Recent average loss: \\(averageRecentLoss), breaking at epoch \\(epoch).\")",
            "        break",
            "    }",
            "    ",
            "    backwardPass()",
            "}"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861687",
            "title": "Listing 20"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "After the training phase completes, the sample calculates the accuracy of the network over a new dataset. It then creates a new batch of random digits and runs a forward pass of the network."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "try fusedConvBatchNormLayer.apply(batchSize: batchSize,",
            "                                  input: input,",
            "                                  output: batchNormOutput,",
            "                                  for: .inference)",
            "",
            "try poolingLayer.apply(batchSize: batchSize,",
            "                       input: batchNormOutput,",
            "                       output: poolingOutput)",
            "",
            "try fullyConnectedLayer.apply(batchSize: batchSize,",
            "                              input: poolingOutput,",
            "                              output: fullyConnectedOutput)"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861688",
            "title": "Listing 21"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "Evaluate the accuracy of the network by comparing the values in the fully connected layer’s output to the one-hot labels. For example, when the recognized digit is "
            },
            {
              "type": "codeVoice",
              "code": "3"
            },
            {
              "type": "text",
              "text": ", one-hot labels contain the values "
            },
            {
              "type": "codeVoice",
              "code": "[0, 0, 0, 1, 0, 0, 0, 0, 0, 0]"
            },
            {
              "type": "text",
              "text": ", and values in the fully connected layer’s output might be as follows:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "[-2.51, -3.62, -0.10, 8.52, -0.42, 5.11, -1.65, 1.34,  0.82, -2.77]",
            "[-3.94, -2.74, -0.30, 8.39, -1.45, 6.02, -0.66, 3.25,  0.49, -3.19]",
            "[-2.51, -2.77, -0.77, 8.41, -0.82, 4.87, -0.37, 2.32, -0.49, -3.05]",
            "[-3.01, -2.79,  0.48, 7.95, -2.57, 4.55, -1.05, 1.67,  1.38, -1.43]",
            "[-2.48, -1.59, -0.97, 7.59, -2.52, 4.00,  0.95, 4.02, -2.10, -1.62]"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861689",
            "title": "Listing 22"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "Note that in each case, the highest value in the fully connected layer’s output is at index "
            },
            {
              "type": "codeVoice",
              "code": "3"
            },
            {
              "type": "text",
              "text": "."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The following code performs that evaluation for each digit in the batch:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "guard",
            "    let fullyConnected = fullyConnectedOutput.makeArray(",
            "        of: Float.self,",
            "        batchSize: batchSize),",
            "    let labels = oneHotLabels.makeArray(",
            "        of: Float.self,",
            "        batchSize: batchSize) else {",
            "    fatalError(\"Unable to create arrays for evaluation.\")",
            "}",
            "",
            "var correctCount = 0",
            "",
            "for sample in 0 ..< batchSize {",
            "    let offset = fullyConnectedOutputWidth * sample",
            "    ",
            "    let fullyConnectedBatch = fullyConnected[offset ..< offset + fullyConnectedOutputWidth]",
            "    let predictedDigit = vDSP.indexOfMaximum(fullyConnectedBatch).0",
            "    ",
            "    let oneHotLabelsBatch = labels[offset ..< offset + fullyConnectedOutputWidth]",
            "    let label = vDSP.indexOfMaximum(oneHotLabelsBatch).0",
            "    ",
            "    if label == predictedDigit {",
            "        correctCount += 1",
            "    }",
            "    ",
            "    print(\"Sample \\(sample) — digit: \\(label) | prediction: \\(predictedDigit)\")",
            "}"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861690",
            "title": "Listing 23"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The evaluation function prints out something like the following:"
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "Sample 0 — digit: 7 | prediction: 7",
            "Sample 1 — digit: 5 | prediction: 5",
            "Sample 2 — digit: 7 | prediction: 7",
            "Sample 3 — digit: 7 | prediction: 7",
            "Sample 4 — digit: 0 | prediction: 0",
            "Sample 5 — digit: 8 | prediction: 8",
            "Sample 6 — digit: 3 | prediction: 3",
            "Sample 7 — digit: 6 | prediction: 6",
            "Sample 8 — digit: 2 | prediction: 2",
            "Sample 9 — digit: 7 | prediction: 7",
            "[ ... ]"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "3861691",
            "title": "Listing 24"
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "In this case, the neural network accurately predicts each ground truth digit."
            }
          ]
        }
      ]
    }
  ],
  "legalNotices": {
    "copyright": "Copyright &copy; 2021 Apple Inc. All rights reserved.",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy"
  }
}