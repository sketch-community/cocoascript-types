{
  "abstract": [
    {
      "type": "text",
      "text": "Learn how to create a simple app that incorporates predicted touches into its drawing code."
    }
  ],
  "documentVersion": 0,
  "hierarchy": {
    "paths": [
      [
        "doc://com.apple.documentation/documentation/technologies",
        "doc://com.apple.documentation/documentation/uikit",
        "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures",
        "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view",
        "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches"
      ]
    ]
  },
  "identifier": {
    "url": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app",
    "interfaceLanguage": "occ"
  },
  "legacy_identifier": 2919337,
  "kind": "article",
  "metadata": {
    "title": "Incorporating Predicted Touches into an App",
    "role": "article",
    "roleHeading": "Article",
    "modules": [
      {
        "name": "UIKit"
      }
    ]
  },
  "schemaVersion": {
    "major": 1,
    "minor": 0,
    "patch": 0
  },
  "sections": [],
  "variants": [
    {
      "traits": [
        {
          "interfaceLanguage": "occ"
        }
      ],
      "paths": [
        "documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app"
      ]
    },
    {
      "traits": [
        {
          "interfaceLanguage": "swift"
        }
      ],
      "paths": [
        "documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app"
      ]
    }
  ],
  "references": {
    "doc://com.apple.documentation/documentation/uikit": {
      "title": "UIKit",
      "identifier": "doc://com.apple.documentation/documentation/uikit",
      "url": "/documentation/uikit",
      "type": "topic",
      "kind": "symbol",
      "role": "collection"
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures": {
      "title": "Touches, Presses, and Gestures",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures",
      "url": "/documentation/uikit/touches_presses_and_gestures",
      "type": "topic",
      "kind": "article",
      "role": "collectionGroup"
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view": {
      "title": "Handling Touches in Your View",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view",
      "type": "topic",
      "kind": "article",
      "role": "article"
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches": {
      "title": "Minimizing Latency with Predicted Touches",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches",
      "type": "topic",
      "kind": "article",
      "role": "article"
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919339": {
      "title": "Listing 1",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919339",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919339",
      "abstract": [
        {
          "type": "text",
          "text": "Collecting predicted touches in Speed Sketch"
        }
      ]
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919340": {
      "title": "Listing 2",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919340",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919340",
      "abstract": [
        {
          "type": "text",
          "text": "Managing predicted samples in the Stroke class"
        }
      ]
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919342": {
      "title": "Listing 3",
      "type": "section",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919342",
      "kind": "article",
      "role": "codeListing",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919342",
      "abstract": [
        {
          "type": "text",
          "text": "Fetching predicted touches during drawing"
        }
      ]
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/leveraging_touch_input_for_drawing_apps": {
      "title": "Leveraging Touch Input for Drawing Apps",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/leveraging_touch_input_for_drawing_apps",
      "kind": "article",
      "role": "sampleCode",
      "url": "/documentation/uikit/touches_presses_and_gestures/leveraging_touch_input_for_drawing_apps"
    },
    "link-media-3004387": {
      "identifier": "link-media-3004387",
      "type": "link",
      "title": "Figure 1",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#3004387"
    },
    "media-3004387": {
      "identifier": "media-3004387",
      "type": "image",
      "variants": [
        {
          "traits": [
            "2x"
          ],
          "size": {
            "width": 678,
            "height": 343
          },
          "url": "https://docs-assets.developer.apple.com/published/7c21d852b9/89660942-617b-4b75-929e-1f928d021f66.png"
        }
      ],
      "alt": "An illustration of the calligraphy, pen, and debug drawing modes in Speed Sketch.",
      "title": "Figure 1",
      "abstract": [
        {
          "type": "text",
          "text": "Speed Sketch drawing modes"
        }
      ]
    },
    "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app": {
      "title": "Incorporating Predicted Touches into an App",
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app",
      "kind": "article",
      "role": "article",
      "url": "/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app",
      "abstract": [
        {
          "type": "text",
          "text": "Learn how to create a simple app that incorporates predicted touches into its drawing code."
        }
      ]
    },
    "doc://com.apple.documentation/documentation/technologies": {
      "type": "topic",
      "identifier": "doc://com.apple.documentation/documentation/technologies",
      "url": "/documentation/technologies",
      "kind": "technologies",
      "title": "Technologies"
    }
  },
  "primaryContentSections": [
    {
      "kind": "content",
      "content": [
        {
          "anchor": "overview",
          "level": 2,
          "text": "Overview",
          "type": "heading"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The sample app Speed Sketch (see "
            },
            {
              "type": "reference",
              "isActive": true,
              "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/leveraging_touch_input_for_drawing_apps"
            },
            {
              "type": "text",
              "text": ") uses predicted touches to minimize latency when drawing using either Apple Pencil or a finger. The key class for gathering touches is the "
            },
            {
              "type": "codeVoice",
              "code": "StrokeGestureRecognizer"
            },
            {
              "type": "text",
              "text": " class. Each new sequence of touch events results in the creation of a "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " object to the app’s drawing canvas. Stroke objects store the touch data needed to do stylized line drawing and can render that data using a calligraphy pen or a regular pen, or in a special debug mode that draws line segments for each distinct touch event."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "image",
              "identifier": "media-3004387",
              "metadata": {
                "anchor": "3004387",
                "title": "Figure 1",
                "abstract": [
                  {
                    "type": "text",
                    "text": "Speed Sketch drawing modes"
                  }
                ]
              }
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": []
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Collect the Touch Input",
          "anchor": "2919338"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The "
            },
            {
              "type": "codeVoice",
              "code": "StrokeGestureRecognizer"
            },
            {
              "type": "text",
              "text": " class collects drawing-related touch input and uses it to create a "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " object representing the path to render. In addition to the touches that actually occurred, the class also gathers any predicted touches. "
            },
            {
              "type": "reference",
              "isActive": false,
              "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919339"
            },
            {
              "type": "text",
              "text": " shows the portion of the gesture recognizer’s "
            },
            {
              "type": "codeVoice",
              "code": "append"
            },
            {
              "type": "text",
              "text": " method that is responsible for gathering the predicted touches. The "
            },
            {
              "type": "codeVoice",
              "code": "collector"
            },
            {
              "type": "text",
              "text": " block called by this code processes each touch event. The parameters to that block indicate whether the touch is an actual touch or a predicted touch."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "// Collect predicted touches only while the gesture is ongoing. ",
            "if (usesPredictedSamples && stroke.state == .active) {",
            "   if let predictedTouches = event?.predictedTouches(for: touchToAppend) {",
            "      for touch in predictedTouches {",
            "         collector(stroke, touch, view, false, true)",
            "      }",
            "   }",
            "}"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "2919339",
            "title": "Listing 1",
            "abstract": [
              {
                "type": "text",
                "text": "Collecting predicted touches in Speed Sketch"
              }
            ]
          }
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "The collection of touch input results in the creation of "
            },
            {
              "type": "codeVoice",
              "code": "StrokeSample"
            },
            {
              "type": "text",
              "text": " objects, which are then added to the current "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " object. Stroke objects store predicted touches separately from other touches. Keeping them separate makes it easier to remove them later, and keeps them from being accidentally confused with the real touch input. Each time the app adds a new set of actual touches, it discards the preceding set of predicted samples."
            }
          ]
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "reference",
              "isActive": false,
              "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919340"
            },
            {
              "type": "text",
              "text": " shows a portion of the "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " class, which represents the touches associated with a single drawn line. For each new set of touches, the class adds the actual touches to its primary list of samples. Any predicted touches are then stored in the "
            },
            {
              "type": "codeVoice",
              "code": "predictedSamples"
            },
            {
              "type": "text",
              "text": " property. Each time "
            },
            {
              "type": "codeVoice",
              "code": "StrokeGestureRecognizer"
            },
            {
              "type": "text",
              "text": " calls the "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " method "
            },
            {
              "type": "codeVoice",
              "code": "add"
            },
            {
              "type": "text",
              "text": ", the method moves the last set of predicted touches to the "
            },
            {
              "type": "codeVoice",
              "code": "previousPredictedSamples"
            },
            {
              "type": "text",
              "text": " property and are ultimately discarded. Thus, "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " maintains only the last set of predicted touches."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "class Stroke {",
            "    static let calligraphyFallbackAzimuthUnitVector = CGVector(dx: 1.0, dy:1.0).normalize! ",
            "    var samples: [StrokeSample] = []",
            "    var predictedSamples: [StrokeSample] = []",
            "    var previousPredictedSamples: [StrokeSample]?",
            "    var state: StrokeState = .active",
            "    var sampleIndicesExpectingUpdates = Set<Int>()",
            "    var expectsAltitudeAzimuthBackfill = false",
            "    var hasUpdatesFromStartTo: Int?",
            "    var hasUpdatesAtEndFrom: Int? ",
            "    var receivedAllNeededUpdatesBlock: (() -> ())?",
            " ",
            "    func add(sample: StrokeSample) -> Int {",
            "        let resultIndex = samples.count",
            "        if hasUpdatesAtEndFrom == nil {",
            "            hasUpdatesAtEndFrom = resultIndex",
            "        }",
            " ",
            "        samples.append(sample)",
            "        if previousPredictedSamples == nil {",
            "            previousPredictedSamples = predictedSamples",
            "        }",
            " ",
            "        if sample.estimatedPropertiesExpectingUpdates != [] {",
            "            sampleIndicesExpectingUpdates.insert(resultIndex)",
            "        }",
            " ",
            "        predictedSamples.removeAll()",
            "        return resultIndex",
            "    } ",
            " ",
            "    func addPredicted(sample: StrokeSample) {",
            "        predictedSamples.append(sample)",
            "    } ",
            " ",
            "    func clearUpdateInfo() {",
            "        hasUpdatesFromStartTo = nil",
            "        hasUpdatesAtEndFrom = nil",
            "        previousPredictedSamples = nil",
            "    } ",
            " ",
            "    // Other methods...",
            "}"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "2919340",
            "title": "Listing 2",
            "abstract": [
              {
                "type": "text",
                "text": "Managing predicted samples in the Stroke class"
              }
            ]
          }
        },
        {
          "type": "paragraph",
          "inlineContent": []
        },
        {
          "type": "paragraph",
          "inlineContent": []
        },
        {
          "level": 3,
          "type": "heading",
          "text": "Render the Predicted Touches",
          "anchor": "2919341"
        },
        {
          "type": "paragraph",
          "inlineContent": [
            {
              "type": "text",
              "text": "During rendering, the app treats predicted touches like actual touches. It breaks down the contents of each "
            },
            {
              "type": "codeVoice",
              "code": "Stroke"
            },
            {
              "type": "text",
              "text": " object into one or more "
            },
            {
              "type": "codeVoice",
              "code": "StrokeSegment"
            },
            {
              "type": "text",
              "text": " objects, which the drawing code fetches using a "
            },
            {
              "type": "codeVoice",
              "code": "StrokeSegmentIterator"
            },
            {
              "type": "text",
              "text": " object. "
            },
            {
              "type": "reference",
              "isActive": false,
              "identifier": "doc://com.apple.documentation/documentation/uikit/touches_presses_and_gestures/handling_touches_in_your_view/minimizing_latency_with_predicted_touches/incorporating_predicted_touches_into_an_app#2919342"
            },
            {
              "type": "text",
              "text": " shows the implementation of this class. As the drawing code iterates over the stroke samples, the "
            },
            {
              "type": "codeVoice",
              "code": "sampleAt"
            },
            {
              "type": "text",
              "text": " method returns the samples for the actual touches first. Only after the method returns all of the actual touch samples does the iterator return the samples for any predicted touches. Thus, the predicted touches are always located at the end of the stroked line."
            }
          ]
        },
        {
          "type": "codeListing",
          "code": [
            "class StrokeSegmentIterator: IteratorProtocol {",
            "    private let stroke: Stroke",
            "    private var nextIndex: Int",
            "    private let sampleCount: Int",
            "    private let predictedSampleCount: Int",
            "    private var segment: StrokeSegment!",
            " ",
            "    init(stroke: Stroke) {",
            "        self.stroke = stroke",
            "        nextIndex = 1",
            "        sampleCount = stroke.samples.count",
            "        predictedSampleCount = stroke.predictedSamples.count",
            "        if (predictedSampleCount + sampleCount > 1) {",
            "            segment = StrokeSegment(sample: sampleAt(0)!)",
            "            segment.advanceWithSample(incomingSample: sampleAt(1))",
            "        }",
            "    } ",
            " ",
            "    func sampleAt(_ index: Int) -> StrokeSample? {",
            "        if (index < sampleCount) {",
            "            return stroke.samples[index]",
            "        }",
            "        let predictedIndex = index - sampleCount",
            "        if predictedIndex < predictedSampleCount {",
            "            return stroke.predictedSamples[predictedIndex]",
            "        } else {",
            "            return nil",
            "        }",
            "    }",
            " ",
            "    func next() -> StrokeSegment? {",
            "        nextIndex += 1",
            "        if let segment = self.segment {",
            "            if segment.advanceWithSample(incomingSample: sampleAt(nextIndex)) {",
            "                return segment",
            "            }",
            "        }",
            "        return nil",
            "    }",
            "}"
          ],
          "syntax": "swift",
          "metadata": {
            "anchor": "2919342",
            "title": "Listing 3",
            "abstract": [
              {
                "type": "text",
                "text": "Fetching predicted touches during drawing"
              }
            ]
          }
        },
        {
          "type": "paragraph",
          "inlineContent": []
        },
        {
          "type": "paragraph",
          "inlineContent": []
        }
      ]
    }
  ],
  "legalNotices": {
    "copyright": "Copyright &copy; 2020 Apple Inc. All rights reserved.",
    "termsOfUse": "https://www.apple.com/legal/internet-services/terms/site.html",
    "privacyPolicy": "https://www.apple.com/privacy/privacy-policy"
  }
}